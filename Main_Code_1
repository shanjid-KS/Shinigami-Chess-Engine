#!/usr/bin/env python3
"""
Shinigami V.1.15.4 - Professional Chess Engine with Full Tree Parallelization and Advanced NNUE
Author: Tonmoy-KS
License: MIT License (credit @Tonmoy-KS, do not claim as own)
"""

import chess
import chess.syzygy
import chess.polyglot
import random
import time
import logging
import multiprocessing as mp
from multiprocessing import Manager, Pool
from collections import defaultdict
import numpy as np
import os
from scipy.sparse import csr_matrix
import sqlite3
import torch
import torch.nn as nn
import tkinter as tk
from PIL import Image, ImageTk

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    filename='shinigami_engine.log'
)

class ShinigamiConfig:
    """Configuration settings for the Shinigami chess engine."""
    ENGINE_NAME = "Shinigami V.1.15.4 - Gen 2 Edition"
    PIECE_VALUES = {
        chess.PAWN: 150,
        chess.KNIGHT: 520,
        chess.BISHOP: 530,
        chess.ROOK: 800,
        chess.QUEEN: 1000,
        # King value omitted as it’s not used in material evaluation
    }
    TIME_CONTROLS = {
        'easy': {'base': 120, 'increment': 1},
        'medium': {'base': 300, 'increment': 3},
        'hard': {'base': 600, 'increment': 5},
        'god-of-death': {'base': 650, 'increment': 50},
        'puzzle': {'base': 30, 'increment': 0},
        'masochist': {'base': 70, 'increment': 15},
        'dialing-satan-s-number': {'base': 2,177,430,688,000,000,000, 'increment': 30} # yeah, that's 69 Eons 
    }
    DEPTHS = {
        'easy': 1,
        'medium': 6,
        'hard': 14,
        'god-of-death': 24,
        'puzzle': 4,
        'masochist': 40,
        'dialing-satan-s-number': 85000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000  # Yeah that's Eighty Five Trivigintrillion because it's a Joke difficulty
    }
    NNUE_FILE = 'nnue_weights.bin'
    SYZYGY_PATH = 'C:\\Tablebases'
    USE_NNUE = False # Current Stopped because of Reasons you can turn it on it neede
    NUM_PROCESSES = max(1, mp.cpu_count() // 2)
    PIECE_SQUARE_TABLES = {
        chess.PAWN: [
            0, 0, 0, 0, 0, 0, 0, 0,
            50, 50, 50, 50, 50, 50, 50, 50,
            10, 10, 20, 30, 30, 20, 10, 10,
            5, 5, 10, 25, 25, 10, 5, 5,
            0, 0, 0, 20, 20, 0, 0, 0,
            5, -5, -10, 0, 0, -10, -5, 5,
            5, 10, 10, -20, -20, 10, 10, 5,
            0, 0, 0, 0, 0, 0, 0, 0
        ],
        chess.KNIGHT: [
            -50, -40, -30, -30, -30, -30, -40, -50,
            -40, -20, 0, 0, 0, 0, -20, -40,
            -30, 0, 10, 15, 15, 10, 0, -30,
            -30, 5, 15, 20, 20, 15, 5, -30,
            -30, 0, 15, 20, 20, 15, 0, -30,
            -30, 5, 10, 15, 15, 10, 5, -30,
            -40, -20, 0, 5, 5, 0, -20, -40,
            -50, -40, -30, -30, -30, -30, -40, -50
        ],
        chess.BISHOP: [
            -20, -10, -10, -10, -10, -10, -10, -20,
            -10, 0, 0, 0, 0, 0, 0, -10,
            -10, 0, 5, 10, 10, 5, 0, -10,
            -10, 5, 5, 10, 10, 5, 5, -10,
            -10, 0, 10, 10, 10, 10, 0, -10,
            -10, 10, 10, 0, 0, 10, 10, -10,
            -10, 5, 0, 0, 0, 0, 5, -10,
            -20, -10, -10, -10, -10, -10, -10, -20
        ],
        chess.ROOK: [
            0, 0, 0, 0, 0, 0, 0, 0,
            5, 10, 10, 10, 10, 10, 10, 5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            -5, 0, 0, 0, 0, 0, 0, -5,
            0, 0, 0, 5, 5, 0, 0, 0
        ],
        chess.QUEEN: [
            -20, -10, -10, -5, -5, -10, -10, -20,
            -10, 0, 0, 0, 0, 0, 0, -10,
            -10, 0, 5, 5, 5, 5, 0, -10,
            -5, 0, 5, 5, 5, 5, 0, -5,
            0, 0, 5, 5, 5, 5, 0, -5,
            -10, 5, 5, 5, 5, 5, 0, -10,
            -10, 0, 5, 0, 0, 0, 0, -10,
            -20, -10, -10, -5, -5, -10, -10, -20
        ],
        chess.KING: [
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -30, -40, -40, -50, -50, -40, -40, -30,
            -20, -30, -30, -40, -40, -30, -30, -20,
            -10, -20, -20, -20, -20, -20, -20, -10,
            20, 20, 0, 0, 0, 0, 20, 20,
            20, 30, 10, 0, 0, 10, 30, 20
        ]
    }
    TRASH_TALK = {
        "move": [
            "Keep up, or I'll Ctrl+Alt+Del your whole board.",
            "Your moves are so predictable. I'm playing blindfolded.",
            "I'm two moves from reaping your soul. Hurry up."
        ],
        "check": [
            "Check! Your king's trembling already.",
            "Check! Time to panic or pray—your choice.",
            "Check! I'm carving your board like a Halloween pumpkin."
        ],
        "capture": [
            "Yoink! That piece is mine now.",
            "Captured. You're running out of toys.",
            "Snagged your piece. Should've seen that fork coming."
        ],
        "win": [
            "GG, I just Alt+F4'd your entire existence!",
            "Checkmate! Your rating's in the shadow realm now.",
            "Game over. I just reaped your soul. GG."
        ],
        "draw": [
            "Draw? You survived... barely. I'm disappointed.",
            "Stalemate? That's the saddest ending possible.",
            "Draw? I'll haunt your next game, don't worry."
        ],
        "loss": [
            "You got plot armor or what? White wins... for now.",
            "White wins. Enjoy it while it lasts, mortal.",
            "You won? Must've been my coffee break."
        ],
        "invalid": [
            "That's not a move, it's a cry for help!",
            "Illegal move! Do you even chess, bro?",
            "Invalid move! Did you borrow that from a 1000-rated game?"
            " I can't differentiate if your Playing Wrong or Existing the Wrong Way."
        ],
        "opening": [
            "You brought the London System? Weak.",
            "King's Pawn Opening? How original.",
            "Sicilian? Bold, but I'm still gonna shred you."
            "You still follow Theory? i am the Einstein of Chess"
        ],
        "time_pressure": [
            "Tick-tock, your clock's screaming for mercy.",
            "Time's burning, just like your position.",
            "Low on time? I'll finish this before you blink."
        ]
    }

class NNUE(nn.Module):
    """Neural Network for position evaluation using HalfKAv2 feature set."""
    def __init__(self, input_size=40960, hidden_size=512):
        super(NNUE, self).__init__()
        self.input_layer = nn.Linear(input_size, hidden_size)
        self.hidden_layer = nn.Linear(hidden_size, hidden_size)
        self.output_layer = nn.Linear(hidden_size, 1)
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.input_layer(x))
        x = self.relu(self.hidden_layer(x))
        return self.output_layer(x)

class AdvancedNNUEEvaluator:
    """Handles advanced NNUE evaluation with HalfKAv2 feature set."""
    def __init__(self, nnue_file: str):
        self.input_size = 40960  # HalfKAv2 feature set
        self.model = NNUE()
        try:
            self.model.load_state_dict(torch.load(nnue_file))
            logging.info("Loaded NNUE weights")
        except Exception as e:
            logging.warning(f"Failed to load NNUE weights: {e}")
            self.model = None

    def evaluate(self, board: chess.Board) -> int:
        """Evaluate board using NNUE or fallback to traditional evaluation.
        
        Args:
            board: The current chess board position.
        
        Returns:
            Integer score in centipawns (positive favors White, negative favors Black).
        """
        if self.model is None:
            return 0  # Fallback to traditional evaluation
        features = self.encode_halfkav2(board)
        with torch.no_grad():
            score = self.model(torch.tensor(features, dtype=torch.float32)).item()
        return int(score * 100)  # Convert to centipawns

    def encode_halfkav2(self, board: chess.Board) -> np.ndarray:
        """Encode board state into HalfKAv2 features (simplified placeholder).
        
        Args:
            board: The current chess board position.
        
        Returns:
            Numpy array of features for NNUE input.
        """
        features = np.zeros(self.input_size, dtype=np.float32)
        idx = 0
        for square in chess.SQUARES:
            piece = board.piece_at(square)
            if piece:
                piece_idx = piece.piece_type - 1 + (6 if piece.color == chess.BLACK else 0)
                features[idx + piece_idx * 64 + square] = 1.0
        return features

class TrainingModule:
    """Manages self-play and training for opening book and NNUE weights."""
    def __init__(self):
        self.conn = sqlite3.connect('shinigami_games.db')
        self.conn.execute('''CREATE TABLE IF NOT EXISTS games
                            (id INTEGER PRIMARY KEY, fen TEXT, move TEXT, result TEXT)''')
        self.opening_book = defaultdict(lambda: {'weight': 1.0})

    def self_play(self, engine, num_games=100):
        """Run self-play games to generate training data.
        
        Args:
            engine: ShinigamiEngine instance.
            num_games: Number of games to play.
        """
        for _ in range(num_games):
            board = chess.Board()
            game_moves = []
            while not board.is_game_over():
                move = engine.get_best_move(board, depth=6, difficulty='medium')
                game_moves.append(move.uci())
                board.push(move)
            result = board.result()
            self.conn.execute("INSERT INTO games (fen, move, result) VALUES (?, ?, ?)",
                             (board.fen(), game_moves[-1], result))
            self.conn.commit()
            self.update_opening_book(board, game_moves, result)

    def update_opening_book(self, board: chess.Board, moves: list, result: str):
        """Update opening book weights based on game outcomes.
        
        Args:
            board: The final board position.
            moves: List of move UCI strings.
            result: Game result ('1-0', '0-1', or '1/2-1/2').
        """
        board.reset()
        weight = 1.0 if result in ['1-0', '0-1'] else 0.5
        for move in moves[:10]:  # Update first 10 moves
            zobrist_hash = chess.polyglot.zobrist_hash(board)
            self.opening_book[zobrist_hash]['weight'] += weight
            board.push_uci(move)

    def train_nnue(self, dataset, epochs=10):
        """Train NNUE model on a dataset of (FEN, evaluation) pairs.
        
        Args:
            dataset: List of (FEN, evaluation) tuples.
            epochs: Number of training epochs.
        """
        model = NNUE()
        optimizer = torch.optim.Adam(model.parameters(), lr=0.001)
        criterion = nn.MSELoss()
        for epoch in range(epochs):
            for fen, target_eval in dataset:
                board = chess.Board(fen)
                features = self.encode_halfkav2(board)
                output = model(torch.tensor(features, dtype=torch.float32))
                loss = criterion(output, torch.tensor([target_eval], dtype=torch.float32))
                optimizer.zero_grad()
                loss.backward()
                optimizer.step()
            logging.info(f"Epoch {epoch + 1}/{epochs} completed")
        torch.save(model.state_dict(), ShinigamiConfig.NNUE_FILE)

    def retrain_nnue(self):
        """Retrain NNUE using self-play game data."""
        dataset = []
        for row in self.conn.execute("SELECT fen, result FROM games"):
            fen, result = row
            eval_score = 1.0 if result == '1-0' else -1.0 if result == '0-1' else 0.0
            dataset.append((fen, eval_score))
        if dataset:
            self.train_nnue(dataset)

class ChessGUI:
    """Graphical interface for Shinigami using tkinter."""
    def __init__(self, engine):
        self.engine = engine
        self.board = chess.Board()
        self.root = tk.Tk()
        self.root.title("Shinigami Chess")
        self.canvas = tk.Canvas(self.root, width=400, height=400)
        self.canvas.pack()
        self.status = tk.Label(self.root, text="Select difficulty")
        self.status.pack()
        self.move_input = tk.Entry(self.root)
        self.move_input.pack()
        self.move_input.bind("<Return>", self.handle_move)
        self.ai_color = chess.BLACK
        self.difficulty = self.engine.select_difficulty()
        self.depth = self.engine.config.DEPTHS[self.difficulty]
        self.draw_board()

    def draw_board(self):
        """Draw the chessboard and pieces."""
        self.canvas.delete("all")
        for i in range(8):
            for j in range(8):
                color = "white" if (i + j) % 2 == 0 else "gray"
                self.canvas.create_rectangle(j * 50, i * 50, (j + 1) * 50, (i + 1) * 50, fill=color)
        for square in chess.SQUARES:
            piece = self.board.piece_at(square)
            if piece:
                # Simplified piece rendering (use images in production)
                self.canvas.create_text((chess.square_file(square) * 50 + 25, (7 - chess.square_rank(square)) * 50 + 25),
                                       text=piece.symbol())
        self.status.config(text=f"{'White' if self.board.turn == chess.WHITE else 'Black'} to move")
        if self.board.is_game_over():
            result = self.board.result()
            self.status.config(text=f"Game over: {result}")
        self.root.after(100, self.update)

    def handle_move(self, event):
        """Handle human move input."""
        move_input = self.move_input.get().strip().lower()
        if move_input == "quit":
            self.root.quit()
        try:
            move = self.board.parse_san(move_input)
            if move in self.board.legal_moves:
                self.board.push(move)
                self.draw_board()
                self.move_input.delete(0, tk.END)
            else:
                self.status.config(text=random.choice(self.engine.config.TRASH_TALK["invalid"]))
        except ValueError:
            self.status.config(text=random.choice(self.engine.config.TRASH_TALK["invalid"]))

    def update(self):
        """Update board and handle AI moves."""
        if self.board.turn == self.ai_color and not self.board.is_game_over():
            move = self.engine.get_best_move(self.board, self.depth, self.difficulty)
            if move:
                self.board.push(move)
                self.draw_board()
                if self.board.is_check():
                    self.status.config(text=random.choice(self.engine.config.TRASH_TALK["check"]))
                elif self.board.is_capture(move):
                    self.status.config(text=random.choice(self.engine.config.TRASH_TALK["capture"]))
        self.root.after(100, self.update)

class ShinigamiEngine:
    """Main chess engine class with advanced evaluation and search."""
    def __init__(self):
        """Initialize the chess engine."""
        self.config = ShinigamiConfig()
        self.tablebase = None
        try:
            self.tablebase = chess.syzygy.open_tablebase(self.config.SYZYGY_PATH)
            logging.info("Loaded Syzygy tablebase")
        except Exception as e:
            logging.warning(f"Failed to load Syzygy tablebase: {e}")
        self.opening_book = None
        try:
            self.opening_book = chess.polyglot.open_reader("book.bin")
            logging.info("Loaded Polyglot opening book")
        except Exception as e:
            logging.warning(f"Failed to load Polyglot opening book: {e}")
        self.manager = Manager()
        self.transposition_table = self.manager.dict()
        self.tt_max_size = 10000000
        self.killer_moves = defaultdict(list)
        self.puzzle_database = [
            {"fen": "rnbqkb1r/pppp1ppp/5n2/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R w KQkq - 0 1",
             "move": "Nf3", "task": "Find the best move to develop a piece."}
        ]
        self.nnue = AdvancedNNUEEvaluator(self.config.NNUE_FILE) if self.config.USE_NNUE else None
        self.training_module = TrainingModule()

    def evaluate_position(self, board: chess.Board) -> int:
        """Evaluate the board position using NNUE or traditional heuristics.
        
        Args:
            board: The current chess board position.
        
        Returns:
            Integer score in centipawns (positive favors White, negative favors Black).
        """
        if self.tablebase and board.is_game_over():
            try:
                return self.tablebase.probe_wdl(board) * 1000
            except:
                pass
        if self.config.USE_NNUE and self.nnue:
            return self.nnue.evaluate(board)
        score = 0
        for square in chess.SQUARES:
            piece = board.piece_at(square)
            if piece:
                score += self.config.PIECE_VALUES.get(piece.piece_type, 0) * (1 if piece.color == chess.WHITE else -1)
                pst = self.config.PIECE_SQUARE_TABLES.get(piece.piece_type, [0] * 64)
                score += pst[square if piece.color == chess.WHITE else chess.square_mirror(square)] * (1 if piece.color == chess.WHITE else -1)
        return score

    def see(self, board: chess.Board, move: chess.Move) -> int:
        """Static Exchange Evaluation for a capture move.
        
        Args:
            board: The current chess board position.
            move: The capture move to evaluate.
        
        Returns:
            Integer score representing the material gain/loss of the capture sequence.
        """
        if not board.is_capture(move):
            return 0
        target_square = move.to_square
        attackers = board.attackers(chess.WHITE, target_square) | board.attackers(chess.BLACK, target_square)
        if not attackers:
            return 0
        piece_values = self.config.PIECE_VALUES
        value = piece_values.get(board.piece_at(target_square).piece_type, 0) if board.piece_at(target_square) else 0
        board.push(move)
        gain = [value]
        us = board.turn
        them = not us
        attackers = board.attackers(them, target_square)
        while attackers:
            min_value = float('inf')
            min_piece = None
            for square in attackers:
                piece = board.piece_at(square)
                if piece and piece_values.get(piece.piece_type, 0) < min_value:
                    min_value = piece_values.get(piece.piece_type, 0)
                    min_piece = square
            if min_piece is None:
                break
            move = chess.Move(min_piece, target_square)
            if move not in board.legal_moves:
                break
            board.push(move)
            gain.append(piece_values.get(board.piece_at(target_square).piece_type, 0) if board.piece_at(target_square) else 0)
            us, them = them, us
            attackers = board.attackers(them, target_square)
        board.pop()
        result = gain[0]
        for i in range(1, len(gain), 2):
            result -= gain[i]
            if i + 1 < len(gain):
                result = max(0, result + gain[i + 1])
        return result

    def quiescence(self, board: chess.Board, alpha: int, beta: int, depth_limit: int) -> int:
        """Quiescence search to evaluate quiet positions after captures.
        
        Args:
            board: The current chess board position.
            alpha: Lower bound for alpha-beta pruning.
            beta: Upper bound for alpha-beta pruning.
            depth_limit: Maximum depth for quiescence search.
        
        Returns:
            Integer score in centipawns.
        """
        if depth_limit <= 0 or board.is_game_over():
            return self.evaluate_position(board)
        stand_pat = self.evaluate_position(board)
        if stand_pat >= beta:
            return beta
        alpha = max(alpha, stand_pat)
        move_scores = []
        for move in board.legal_moves:
            if board.is_capture(move) or board.gives_check(move):
                score = self.see(board, move)
                move_scores.append((move, score))
        move_scores.sort(key=lambda x: x[1], reverse=True)
        for move, _ in move_scores:
            board.push(move)
            score = -self.quiescence(board, -beta, -alpha, depth_limit - 1)
            board.pop()
            if score >= beta:
                return beta
            alpha = max(alpha, score)
        return alpha

    def alpha_beta(self, board: chess.Board, depth: int, alpha: int, beta: int, maximizing_player: bool) -> tuple:
        """Alpha-beta pruning with move ordering using SEE and transposition table.
        
        Args:
            board: The current chess board position.
            depth: Search depth.
            alpha: Lower bound for pruning.
            beta: Upper bound for pruning.
            maximizing_player: True if maximizing (White), False if minimizing (Black).
        
        Returns:
            Tuple of (best move, score).
        """
        zobrist_hash = chess.polyglot.zobrist_hash(board)
        tt_entry = self.transposition_table.get(zobrist_hash)
        if tt_entry and tt_entry['depth'] >= depth:
            if tt_entry['flag'] == 'exact':
                return tt_entry['move'], tt_entry['score']
            elif tt_entry['flag'] == 'lower' and tt_entry['score'] >= beta:
                return tt_entry['move'], tt_entry['score']
            elif tt_entry['flag'] == 'upper' and tt_entry['score'] <= alpha:
                return tt_entry['move'], tt_entry['score']
        if depth <= 0 or board.is_game_over():
            return None, self.quiescence(board, alpha, beta, 4)
        move_scores = []
        for move in board.legal_moves:
            score = self.see(board, move) if board.is_capture(move) else 0
            move_scores.append((move, score))
        move_scores.sort(key=lambda x: x[1], reverse=True)
        ordered_moves = [move for move, _ in move_scores]
        best_move = None
        if maximizing_player:
            value = -float('inf')
            for move in ordered_moves:
                board.push(move)
                score = self.alpha_beta(board, depth - 1, alpha, beta, False)[1]
                board.pop()
                if score > value:
                    value = score
                    best_move = move
                alpha = max(alpha, value)
                if alpha >= beta:
                    break
            flag = 'exact' if value <= alpha or value >= beta else 'lower'
        else:
            value = float('inf')
            for move in ordered_moves:
                board.push(move)
                score = self.alpha_beta(board, depth - 1, alpha, beta, True)[1]
                board.pop()
                if score < value:
                    value = score
                    best_move = move
                beta = min(beta, value)
                if alpha >= beta:
                    break
            flag = 'exact' if value <= alpha or value >= beta else 'upper'
        if len(self.transposition_table) < self.tt_max_size:
            self.transposition_table[zobrist_hash] = {'move': best_move, 'score': value, 'depth': depth, 'flag': flag}
        return best_move, value

    def iterative_deepening(self, board: chess.Board, depth: int, time_control: dict) -> tuple:
        """Iterative deepening search with time control.
        
        Args:
            board: The current chess board position.
            depth: Maximum search depth.
            time_control: Dictionary with 'base' and 'increment' keys.
        
        Returns:
            Tuple of (best move, score).
        """
        start_time = time.time()
        time_limit = time_control['base'] + time_control['increment'] * (board.fullmove_number - 1)
        best_move = None
        best_score = 0
        current_depth = 1
        while current_depth <= depth and time.time() - start_time < time_limit:
            with Pool(self.config.NUM_PROCESSES) as pool:
                results = pool.starmap(self.alpha_beta, [(board.copy(), current_depth, -float('inf'), float('inf'), board.turn == chess.WHITE)])
                move, score = results[0]  # Aggregate results in production
                if move:
                    best_move = move
                    best_score = score
            current_depth += 1
        return best_move, best_score

    def get_best_move(self, board: chess.Board, depth: int, difficulty: str) -> chess.Move:
        """Get best move, prioritizing opening book then alpha-beta.
        
        Args:
            board: The current chess board position.
            depth: Search depth.
            difficulty: Difficulty mode.
        
        Returns:
            Best move as a chess.Move object.
        """
        move = self.get_opening_move(board)
        if move and move in board.legal_moves:
            return move
        return self.iterative_deepening(board, depth, self.config.TIME_CONTROLS[difficulty])[0]

    def get_opening_move(self, board: chess.Board) -> chess.Move:
        """Get move from Polyglot opening book.
        
        Args:
            board: The current chess board position.
        
        Returns:
            Move from opening book or None.
        """
        if self.opening_book:
            try:
                entry = self.opening_book.weighted_choice(board)
                return entry.move
            except:
                return None
        return None

    def generate_puzzle(self, board: chess.Board) -> tuple:
        """Generate a puzzle from the puzzle database.
        
        Args:
            board: The current chess board position.
        
        Returns:
            Tuple of (puzzle move, task description) or (None, None).
        """
        if self.puzzle_database:
            puzzle = random.choice(self.puzzle_database)
            board.set_fen(puzzle['fen'])
            return board.parse_san(puzzle['move']), puzzle['task']
        return None, None

    def select_difficulty(self) -> str:
        """Select AI difficulty with confirmation for extreme modes.
        
        Returns:
            Selected difficulty as a string.
        """
        print("Select AI difficulty: 1) Easy, 2) Medium, 3) Hard, 4) God-Of-Death, 5) Puzzle Mode, 6) Masochist, 7) Dialing Satan's Number")
        while True:
            difficulty_input = input("Enter 1, 2, 3, 4, 5, 6, or 7: ").strip()
            difficulties = {'1': 'easy', '2': 'medium', '3': 'hard', '4': 'god-of-death', '5': 'puzzle', '6': 'masochist', '7': 'dialing-satan-s-number'}
            if difficulty_input in difficulties:
                difficulty = difficulties[difficulty_input]
                if difficulty == 'dialing-satan-s-number':
                    for i in range(3):
                        confirm = input(f"Confirm enabling Dialing Satan's Number (step {i+1}/3) [y/n]: ").strip().lower()
                        if confirm != 'y':
                            print("Extreme mode cancelled.")
                            break
                    else:
                        print("Warning: Dialing Satan's Number enabled. Good luck!")
                        return difficulty
                return difficulty
            print("Invalid input. Try again.")

    def play_chess_with_ai(self, ai_color: chess.Color):
        """Main game loop for human vs. AI play in console mode.
        
        Args:
            ai_color: Color the AI plays (chess.WHITE or chess.BLACK).
        """
        board = chess.Board()
        difficulty = self.select_difficulty()
        depth = self.config.DEPTHS[difficulty]
        print(f"NNUE: {'Enabled' if self.config.USE_NNUE else 'Disabled'}")
        print(f"Syzygy Tablebases: {'Loaded' if self.tablebase else 'Not Loaded'}")
        print(f"Opening Book: {'Loaded' if self.opening_book else 'Not Loaded'}")
        logging.info(f"Game started: AI as {'Black' if ai_color == chess.BLACK else 'White'}, Difficulty: {difficulty}")
        while not board.is_game_over():
            print(f"\n{board}\n")
            player = "White" if board.turn == chess.WHITE else "Black"
            print(f"{player}'s turn. Don't bore me.")
            if difficulty == "puzzle":
                puzzle_move, puzzle_task = self.generate_puzzle(board)
                if puzzle_move:
                    print(f"Puzzle Mode: {puzzle_task}\n")
                    while True:
                        move_input = input("Your move (or 'retry'/'exit'): ").strip().lower()
                        if move_input == "exit":
                            logging.info("Player exited puzzle mode")
                            return
                        elif move_input == "retry":
                            continue
                        try:
                            move = board.parse_san(move_input)
                            if move == puzzle_move:
                                print("Puzzle solved! Want another? (y/n)")
                                logging.info("Puzzle solved correctly")
                                if input().strip().lower() == 'y':
                                    board = chess.Board()
                                    puzzle_move, puzzle_task = self.generate_puzzle(board)
                                    if not puzzle_move:
                                        print("No more puzzles available. Switching to medium mode.")
                                        difficulty = "medium"
                                        depth = self.config.DEPTHS["medium"]
                                        break
                                    print(f"\nNew Puzzle: {puzzle_task}\n")
                                else:
                                    return
                            else:
                                print("Wrong move! Try again or 'retry'.")
                                logging.warning(f"Incorrect puzzle move: {move_input}")
                        except ValueError:
                            print(random.choice(self.config.TRASH_TALK["invalid"]))
                            continue
            elif board.turn == ai_color:
                print("Shinigami is plotting your demise...")
                move = self.get_best_move(board, depth, difficulty)
                if move:
                    board.push(move)
                    logging.info(f"AI move: {move}")
                    if board.is_check():
                        print(random.choice(self.config.TRASH_TALK["check"]))
                    elif board.is_capture(move):
                        print(random.choice(self.config.TRASH_TALK["capture"]))
            else:
                move_input = input("Your move: ").strip().lower()
                if move_input == "quit":
                    break
                try:
                    move = board.parse_san(move_input)
                    board.push(move)
                except ValueError:
                    print(random.choice(self.config.TRASH_TALK["invalid"]))
                    logging.warning(f"Invalid move input: {move_input}")
        result = board.result()
        if result == "1-0":
            print(random.choice(self.config.TRASH_TALK["loss"]))
            logging.info("Game ended: White wins")
        elif result == "0-1":
            print(random.choice(self.config.TRASH_TALK["win"]))
            logging.info("Game ended: Black wins")
        else:
            print(random.choice(self.config.TRASH_TALK["draw"]))
            logging.info("Game ended: Draw")

    def uci_loop(self):
        """Handle UCI protocol commands for integration with chess GUIs."""
        board = chess.Board()
        while True:
            command = input().strip()
            if command == "uci":
                print(f"id name {self.config.ENGINE_NAME}")
                print("id author Tonmoy-KS")
                print("option name UseNNUE type check default true")
                print("uciok")
            elif command == "isready":
                print("readyok")
            elif command == "stop":
                break  # Simplified; add proper search stopping in production
            elif command.startswith("setoption name UseNNUE"):
                self.config.USE_NNUE = "value true" in command.lower()
                print(f"info string NNUE {'enabled' if self.config.USE_NNUE else 'disabled'}")
            elif command.startswith("position"):
                parts = command.split()
                board = chess.Board()
                if parts[1] == "startpos" and "moves" in parts:
                    moves = parts[parts.index("moves") + 1:]
                    for move in moves:
                        board.push_uci(move)
            elif command.startswith("go"):
                difficulty = "hard"
                depth = self.config.DEPTHS[difficulty]
                time_control = self.config.TIME_CONTROLS[difficulty]
                move = self.iterative_deepening(board, depth, time_control)[0]
                print(f"bestmove {move.uci()}")
            elif command == "quit":
                break

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Shinigami Chess Engine")
    parser.add_argument('--cores', type=int, default=ShinigamiConfig.NUM_PROCESSES, help="Number of CPU cores to use")
    parser.add_argument('--gui', action='store_true', help="Run with GUI")
    parser.add_argument('--self-play', type=int, default=0, help="Run self-play for specified number of games")
    args = parser.parse_args()
    ShinigamiConfig.NUM_PROCESSES = min(max(1, args.cores), mp.cpu_count())
    mp.set_start_method('spawn')
    engine = ShinigamiEngine()
    if args.self_play > 0:
        engine.training_module.self_play(engine, args.self_play)
        engine.training_module.retrain_nnue()
    elif args.gui:
        gui = ChessGUI(engine)
        gui.root.mainloop()
    else:
        engine.play_chess_with_ai(chess.BLACK